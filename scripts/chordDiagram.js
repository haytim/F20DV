const migrationMatricesFile = "/data/internal_migration_matrices.json";

d3.json(migrationMatricesFile).then(data => {
    const selector = "#chord";
    const width = 700; const height = width;

    const year = 2017;
    const {matrix, regions} = data.find(d => d.year === year);

    const outerRadius = Math.min(width, height) * 0.5 - 80;
    const innerRadius = outerRadius - 20;
    const sum = d3.sum(matrix.flat());
    const tickStep = d3.tickStep(0, sum, 100);
    const majorTickStep = d3.tickStep(0, sum, 40);
    const formatValue = d3.formatPrefix(",.0", tickStep);

    const colorScale = index => regionScaleByCode(regions[index]);
    const indexToName = index => regionCodeToName(regions[index]);

    const chord = d3.chordTranspose()
        .padAngle(10 / innerRadius)
        .sortSubgroups(d3.descending);

    const arc = d3.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius);

    const ribbon = d3.ribbon()
        .radius(innerRadius);

    const svg = d3.select(selector)
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [-width / 2, -height / 2, width, height])
        //.attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;");

    const chords = chord(matrix);

    const group = svg.append("g")
    .selectAll()
    .data(chords.groups)
    .join("g");

    const ticks = group.append("g")
        .selectAll()
        .data(d => groupTicks(d, tickStep))
        .join("g")
        .attr("transform", d => `rotate(${d.angle * 180 / Math.PI - 90}) translate(${outerRadius},0)`);

    ticks.append("line")
        .attr("stroke", "black")
        .attr("x2", 6)

    ticks.filter(d => d.value % majorTickStep === 0)
        .append("text")
        .attr("x", 8)
        .attr("dy", "0.3em")
        .attr("transform", d => d.angle > Math.PI ? "rotate(180) translate(-16)" : null)
        .attr("text-anchor", d => d.angle > Math.PI ? "end" : null)
        .text(d => formatValue(d.value));

    group.select("text")
        .attr("font-weight", "bold")
        .text(d => indexToName(d.index))

    const arcs = group.append("path")
        .attr("fill", d => colorScale(d.index))
        .attr("d", arc);
    
    arcs.append("title")
        .text(d => `${indexToName(d.index)}\n${d.value.toLocaleString(navigator.language)} out`)


    const ribbons = svg.append("g")
        .style("isolation", "isolate")
        .selectAll()
        .data(chords)
        .join("path")
        .attr("d", ribbon)
        .style("mix-blend-mode", "multiply")
        .attr("fill", d => colorScale(d.target.index))
        .attr("stroke", "white")

    ribbons.append("title")
        .text(d => `${d.source.value.toLocaleString(navigator.language)} ${indexToName(d.source.index)} → ${indexToName(d.target.index)}${d.source.index !== d.target.index ? `\n${d.target.value.toLocaleString(navigator.language)} ${indexToName(d.target.index)} → ${indexToName(d.source.index)}` : ``}`);

    /**
     * generate tick spacing for chord diagram groups
     * @param {*} d group generated by a d3 chord generator
     * @param {number} step step size
     */
    function groupTicks(d, step) {
        const k = (d.endAngle - d.startAngle) / d.value;
        return d3.range(0, d.value, step).map(value => {
            return {value: value, angle: value * k + d.startAngle}
        })
    }
})
