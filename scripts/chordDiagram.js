const migrationMatricesFile = "/data/internal_migration_matrices.json";

d3.json(migrationMatricesFile).then(data => {
    const selector = "#chord";
    const width = 700; const height = width;

    // get regions. regions are all the same order for each year
    const {regions} = data[0];

    const outerRadius = Math.min(width, height) * 0.5 - 80;
    const innerRadius = outerRadius - 20;

    const colorScale = index => regionScaleByCode(regions[index]);
    const indexToName = index => regionCodeToName(regions[index]);

    const chord = d3.chordTranspose()
        .padAngle(10 / innerRadius)
        .sortSubgroups(d3.descending);

    const arc = d3.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius);

    const ribbon = d3.ribbon()
        .radius(innerRadius);

    const svg = d3.select(selector)
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [-width / 2, -height / 2, width, height])
        .style("font-size", "10px");

    const group = svg.append("g");
    const ribbonGroup = svg.append("g");
    ribbonGroup.style("isolation", "isolate");

    drawChordDiagram(2012);

    function drawChordDiagram(year) {
        const {matrix} = data.find(d => d.year === year);

        const sum = d3.sum(matrix.flat());
        const tickStep = d3.tickStep(0, sum, 150);
        const majorTickStep = d3.tickStep(0, sum, 40);
        const formatValue = d3.formatPrefix(",.0", tickStep);

        const chords = chord(matrix);

        const arcs = group.selectAll(".chord-groups")
            .data(chords.groups)
            .join(
                enter => {
                    const path = enter.append("path");
                    path.append("title");
                    return path;
                }
            )
            .classed("chord-groups", true)
            .style("fill", d => colorScale(d.index))
            .style("stroke", "white")
            .on("mouseover", fade(.1))
            .on("mouseout", fade(1))
            .transition()
            .duration(transitionDuration)
            .attr("d", arc);

        arcs.select("title")
            .text(d => `${indexToName(d.index)}\n${d.value.toLocaleString(navigator.language)} out`)

        const tickGroups = group
            .selectAll(".tick-group")
            .data(chords.groups)
            .join("g")
            .classed("tick-group", true);

        const ticks = tickGroups.selectAll(".tick")
            .data(d => groupTicks(d, tickStep))
            .join(
                enter => {
                    const g = enter.append("g");
                    g.append("line")
                        .attr("stroke", "black")
                        .attr("x2", 6);
                    return g;
                },
                update => {
                    update.selectAll("text").remove();
                    return update;
                }
            )
            .classed("tick", true)
            
        ticks.transition()
            .duration(transitionDuration)
            .attr("transform", d => `rotate(${d.angle * 180 / Math.PI - 90}) translate(${outerRadius},0)`);            
        
        ticks.filter(d => d.value % majorTickStep === 0)
            .append("text")
            .attr("x", 8)
            .attr("dy", "0.3em")
            .attr("transform", d => d.angle > Math.PI ? "rotate(180) translate(-16)" : null)
            .attr("text-anchor", d => d.angle > Math.PI ? "end" : null)
            .text(d => formatValue(d.value));

        tickGroups.select("text")
            .attr("font-weight", "bold")
            .text(d => indexToName(d.index));

        ribbonGroup.selectAll("path").data(chords)
            .join(
                enter => {
                    const path = enter.append("path");
                    path.append("title");
                    return path;
                }
            )
            .classed("ribbon", true)
            .style("mix-blend-mode", "multiply")
            .style("stroke", "white")
            .attr("fill", d => colorScale(d.target.index))
            .transition()
            .duration(transitionDuration)
            .attr("d", ribbon);
        
        ribbonGroup.select("title")
            .text(d => `${d.source.value.toLocaleString(navigator.language)} ${indexToName(d.source.index)} → ${indexToName(d.target.index)}${d.source.index !== d.target.index ? `\n${d.target.value.toLocaleString(navigator.language)} ${indexToName(d.target.index)} → ${indexToName(d.source.index)}` : ``}`);
    }

    /**
     * generate tick spacing for chord diagram groups
     * @param {*} d group generated by a d3 chord generator
     * @param {number} step step size
     */
    function groupTicks(d, step) {
        const k = (d.endAngle - d.startAngle) / d.value;
        return d3.range(0, d.value, step).map(value => {
            return {value: value, angle: value * k + d.startAngle}
        })
    }

    function fade(opacity) {
        return function (_, group) {
            svg.selectAll(".ribbon")
                .filter(d => d.source.index != group.index && d.target.index != group.index)
                .transition()
                .style("opacity", opacity);
        };
    }

    sliderRegisterCallback(function() {
        drawChordDiagram(Number(this.value));
    });
})
